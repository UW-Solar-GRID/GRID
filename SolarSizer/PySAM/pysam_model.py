#!/usr/bin/env python
# coding: utf-8

# In[8]:


import os
import numpy as np
import pandas as pd
import PySAM.Pvsamv1 as pv
import matplotlib.pyplot as plt
import urllib.request
from pysam_utils import pvmodel


# ## Load Profile
# 
# Getting our load profile

# In[9]:


data_path = os.path.abspath("../data")

our_load_profile = np.loadtxt(os.path.join(data_path, "Max_load_profile_for_year.txt"), skiprows=1)



# ## PV Model - "PVBatteryResidential"
# 
# `PVBatteryResidential` is one of the buit-in models in PySAM. We will use it for our analysis as it meets all of our basic requirements.
# 
# - Instantiate the model with default values
# - Specify the solar resource file for the location
# - Assign the load profile (defined above) to the the model. This will inform the model what kind of load our system will support
# - Pick module and inverter models - can design our own with specifications as needed but here we will pick from the available database
# - Identify the minimum and the maximum number of modules that can be in a string (*connected in series*). This is to make sure we are in the operating range for the inverter. The number of modules we select to be connected in a string must fall between these min and max values
# - Design the system :
#     - Set inverter count - *how many inverters do we want?*
#     - For a single subarray:
#         - Assign the number of modules in a string (*modules in series*)
#         - Assign the number of strings (*rows (in parallel)*)
#         - Fixed axis system or tracking (*tracking means it will track the sun throughout the day*)
#     - Repeat for desired number of subarrays
# - Specify Battery system specs: charge, discharge
# - Identify power dispatch from battery
#     - Manually control - specify when to charge and discharge the battery (*this makes more sense if you look at the UI in SAM*)
# - Execute the model!

# Refer [this link](https://sam.nrel.gov/images/webinar_files/sam-webinars-2020-modeling-pv-systems.pdf) for detailed explanation on MMPT, subarray, strings, etc


# ## Single Scenario
# 
# First, we will execute the model for a single sceanario: 
# - `number_of_modules_per_string=5` (*connected in series*)
# - `number_of_strings=6` (*rows of modules in parallel*)
# - `n_inverter=10` (*number of inverters*)


%%time

pvmodel = pvmodel.execute_pvmodel(5, 6, n_inverters=10)


# ### Calculate total system uptime 
# 
# System uptime is basicaly how many hours during the system lifetime will the energy generated by the system be enough or more than the instantaneous load.
# 
# We can calculate this: 
#     `PV SYSTEM TO LOAD` + `BATTERY TO LOAD` - `LOAD PROFILE` > 0

# In[17]:


uptime_hours = np.count_nonzero(
        (np.array(pvmodel.Outputs.system_to_load) + 
         np.array(pvmodel.Outputs.batt_to_load) - 
         np.tile(our_load_profile, 25)  # repeat load profile for 25 years
        ) == 0 
    )
    
uptime_hours/(365 * 24 * 25) , uptime_hours  # percent uptime for 25 years


# In[18]:


months = ["Jan", "Feb", "March", "April", "May", "June", "July", "August", "Sep", "Oct", "Nov", "Dec"]
plt.bar(months, pvmodel.Outputs.monthly_energy)


# ## Running multiple scenarios
# 
# Now, we will evaluate multiple scenarios - we will look at a range of modules numbers and a range of strings to find minimum system requirements that satisfy maximum uptime

# In[19]:


pvmodels_param_dict = []
pvmodels = []


# In[20]:

%%time
for m in range(2,8): # m is no of modules\n    
    for n in range(4,15): # n is no of strings\n        
       # if m*n >=30:\n#             
        l.append([m,n])\n            
        pvmodels_param_dict.append({"modules_per_string" : m, "number_of_strings" : n})\n            
        z = execute_pvmodel(m,n, n_inverters=5)\n            
        pvmodels.append(z)

len(pvmodels)

pvmodels[0]

uptime_percent = []

for i in range(len(pvmodels)):
    uptime_hours = np.count_nonzero(
        (np.array(pvmodels[i].Outputs.system_to_load) + 
         np.array(pvmodels[i].Outputs.batt_to_load) - 
         np.tile(our_load_profile, 25)  # repeat load profile for 25 years
        ) == 0 
    )
    
    uptime_percent.append(uptime_hours/(365 * 24 * 25))


print("UPTIME", uptime_percent)


print("PARAMS", pvmodels_param_dict)



months = ["Jan", "Feb", "March", "April", "May", "June", "July", "August", "Sep", "Oct", "Nov", "Dec"]
plt.bar(months, pvmodels[0].Outputs.monthly_energy)


# In[27]:


(np.array(pvmodels[0].Outputs.system_to_load) + np.array(pvmodels[0].Outputs.batt_to_load) - np.tile(our_load_profile, 25))[-24:]


# In[ ]:




